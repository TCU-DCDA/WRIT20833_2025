<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slide 1 Animation - CSS as Visual Rhetoric</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        #canvas-container {
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <script>
        // CSS properties that will float and morph
        let cssProperties = [];
        let rhetoricalClaims = [];
        let particles = [];

        function setup() {
            let canvas = createCanvas(900, 600);
            canvas.parent('canvas-container');

            // Initialize CSS property particles
            const properties = [
                { text: 'color: #e74c3c', x: 150, y: 150, targetY: 200, color: [231, 76, 60] },
                { text: 'font-size: 48px', x: 450, y: 100, targetY: 180, color: [52, 152, 219] },
                { text: 'text-align: center', x: 700, y: 180, targetY: 220, color: [46, 204, 113] },
                { text: 'margin: 0 auto', x: 200, y: 350, targetY: 380, color: [155, 89, 182] },
                { text: 'font-weight: bold', x: 600, y: 380, targetY: 400, color: [241, 196, 15] },
                { text: 'padding: 3rem', x: 350, y: 480, targetY: 500, color: [230, 126, 34] }
            ];

            properties.forEach(prop => {
                cssProperties.push({
                    text: prop.text,
                    x: prop.x,
                    y: prop.targetY - 50,
                    targetX: prop.x,
                    targetY: prop.targetY,
                    baseY: prop.targetY,
                    color: prop.color,
                    alpha: 0,
                    size: 14,
                    offset: random(TWO_PI)
                });
            });

            // Rhetorical interpretations that emerge
            const claims = [
                { text: 'URGENCY', x: 150, y: 250, sourceIdx: 0 },
                { text: 'EMPHASIS', x: 450, y: 230, sourceIdx: 1 },
                { text: 'CENTRALITY', x: 700, y: 270, sourceIdx: 2 },
                { text: 'VALUE', x: 200, y: 430, sourceIdx: 3 },
                { text: 'IMPORTANCE', x: 600, y: 450, sourceIdx: 4 },
                { text: 'WORTH', x: 350, y: 550, sourceIdx: 5 }
            ];

            claims.forEach(claim => {
                rhetoricalClaims.push({
                    text: claim.text,
                    x: claim.x,
                    y: claim.y,
                    alpha: 0,
                    sourceIdx: claim.sourceIdx,
                    pulsePhase: random(TWO_PI)
                });
            });

            // Background particles for atmosphere
            for (let i = 0; i < 40; i++) {
                particles.push({
                    x: random(width),
                    y: random(height),
                    size: random(2, 5),
                    speedX: random(-0.3, 0.3),
                    speedY: random(-0.3, 0.3),
                    alpha: random(30, 80)
                });
            }
        }

        function draw() {
            background(26, 26, 26);

            // Draw flowing background particles
            drawParticles();

            // Draw connection lines (subtle)
            drawConnections();

            // Animate CSS properties floating in
            drawCSSProperties();

            // Draw emerging rhetorical claims
            drawRhetoricalClaims();

            // Draw central transformation arrow
            drawTransformationSymbol();
        }

        function drawParticles() {
            noStroke();
            particles.forEach(p => {
                fill(255, 255, 255, p.alpha);
                circle(p.x, p.y, p.size);

                p.x += p.speedX;
                p.y += p.speedY;

                if (p.x < 0) p.x = width;
                if (p.x > width) p.x = 0;
                if (p.y < 0) p.y = height;
                if (p.y > height) p.y = 0;
            });
        }

        function drawConnections() {
            let time = frameCount * 0.01;

            cssProperties.forEach((css, i) => {
                if (css.alpha > 150 && rhetoricalClaims[i]) {
                    let claim = rhetoricalClaims[i];
                    if (claim.alpha > 100) {
                        stroke(css.color[0], css.color[1], css.color[2], 60);
                        strokeWeight(1);
                        line(css.x, css.y, claim.x, claim.y);
                    }
                }
            });
        }

        function drawCSSProperties() {
            let time = frameCount * 0.01;

            cssProperties.forEach((css, i) => {
                // Ease in animation
                if (frameCount > i * 20) {
                    css.alpha = min(255, css.alpha + 3);
                    css.y = lerp(css.y, css.targetY + sin(time + css.offset) * 8, 0.05);
                }

                // Draw CSS property with glow
                fill(css.color[0], css.color[1], css.color[2], css.alpha * 0.3);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(css.size + 2);
                text(css.text, css.x, css.y);

                fill(css.color[0], css.color[1], css.color[2], css.alpha);
                textSize(css.size);
                text(css.text, css.x, css.y);

                // Subtle particle emission
                if (frameCount % 10 === 0 && css.alpha > 200) {
                    particles.push({
                        x: css.x + random(-10, 10),
                        y: css.y,
                        size: random(1, 3),
                        speedX: random(-0.5, 0.5),
                        speedY: random(-1, -0.2),
                        alpha: random(100, 200)
                    });
                }
            });
        }

        function drawRhetoricalClaims() {
            let time = frameCount * 0.01;

            rhetoricalClaims.forEach((claim, i) => {
                // Delay emergence until CSS property is visible
                if (frameCount > (i * 20) + 60) {
                    claim.alpha = min(200, claim.alpha + 2);
                }

                // Pulsing effect
                let pulse = sin(time * 2 + claim.pulsePhase) * 0.15 + 1;
                let sourceColor = cssProperties[claim.sourceIdx].color;

                // Draw with italic style and glow
                push();
                translate(claim.x, claim.y);

                // Outer glow
                fill(sourceColor[0], sourceColor[1], sourceColor[2], claim.alpha * 0.4);
                textStyle(ITALIC);
                textAlign(CENTER, CENTER);
                textSize(16 * pulse);
                text(claim.text, 0, 0);

                // Inner text
                fill(255, 255, 255, claim.alpha);
                textSize(15 * pulse);
                text(claim.text, 0, 0);

                pop();
            });
        }

        function drawTransformationSymbol() {
            if (frameCount > 180) {
                let alpha = min(200, (frameCount - 180) * 2);
                let pulse = sin(frameCount * 0.05) * 5;

                push();
                translate(width/2, height/2);

                // Circular glow
                noStroke();
                fill(100, 200, 255, alpha * 0.2);
                circle(0, 0, 120 + pulse);

                // Arrow symbol
                stroke(100, 200, 255, alpha);
                strokeWeight(3);
                noFill();

                // Curved transformation arrow
                beginShape();
                for (let a = -PI; a < 0; a += 0.1) {
                    let r = 40;
                    let x = cos(a) * r;
                    let y = sin(a) * r - 20;
                    vertex(x, y);
                }
                endShape();

                // Arrow head
                line(40, -20, 30, -28);
                line(40, -20, 30, -12);

                // Text
                textAlign(CENTER, CENTER);
                textSize(12);
                fill(100, 200, 255, alpha);
                noStroke();
                text('TRANSFORMS', 0, 35);

                pop();
            }
        }

        // Clean up old particles
        if (frameCount % 60 === 0) {
            particles = particles.filter(p => p.alpha > 10);
        }
    </script>
</body>
</html>
